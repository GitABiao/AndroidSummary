# Java基础知识
## JavaGC机制
## HashMap的实现机制，怎么样HashMap线程安全
## 可重入锁的实现，公平锁非公平锁都是什么定义？
## 都用过那些常用的数据结构，说说对树的了解？
## HashMap如果Hash冲突了怎么解决？
## Finalize机制
## 强引用 弱引用 软引用 虚引用的区别和使用场景
## ClassLoader的双亲委托
## Java基础
## 继承
## 多态
### 对java多态的理解
### Java中实现多态的机制是什么？
## 封装
## 字符串String、数组、数据类型转换
### Java中String的了解
### String，Stringbuffer，Stringbuilder三者的区别
### String为什么要设计成不可变的？
### string 转换成 integer的方式及原理
### int、char、long各占多少字节数
### int与integer的区别
## java中==和equals和hashCode的区别
## Object类的equal和hashCode方法重写，为什么？
## 修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？
## 线程sleep和wait有什么区别
## 闭包和局部内部类的区别
## 进程和线程的区别
## 序列化的方式
## 如何将一个Java对象序列化到文件里？
## Serializable 和Parcelable 的区别
## 静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？
## 什么是内部类？内部类的作用
## 静态内部类的设计意图
## 成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用
## Java的异常体系
## final，finally，finalize的区别
## 说说你对Java反射的理解
## 说说你对Java注解的理解
## 说说你对依赖注入的理解
## 静态代理和动态代理的区别，什么场景使用？  

# Java多线程
## 1、基础知识
### 1.1 线程安全性
    当多个线程访问某个类的时候，这个类始终能保证正确的行为，这个类就是线程安全的。
#### 1.1.1 原子性
##### 1.1.1.1 竞态条件
    再并发编程中，由于不恰当的时序而出现的问题叫做竞态条件
    1、先检查后执行
##### 1.1.1.2 复合操作
    一组必须已原子方式执行的操作
#### 1.1.2 加锁机制
##### 1.1.2.1 内置锁
    同步代码块，包含一个作为锁的对象的引用，一个作为由这个锁保护的代码块。
    使用synchronized关键字修饰的方法就是横跨整个方法体的同步代码块，该代码块的锁是调用这个方法的对象。静态的synchronized方法以Class对象为锁。
    线程进入同步代码块时会自动获取锁，离开代码块时自动释放锁。
    内置锁相当于互斥体，同时只能有一个线程能获取锁，当一个线程想要去访问一个正在被访问的其他线程持有的锁时线程将会阻塞直到该锁被释放。
##### 1.1.2.2 重入
    因为内置锁时可重入的，所以如果某个线程想要获取一个它已经持有的锁的时候，这个请求将会成功。
#### 1.1.3 使用锁保护状态
    使用synchronized的缺陷：1、导致程序中出现过多的同步。2、无法解决多个操作合并的复合操作。3、可能会导致活跃性问题和性能问题。
#### 1.1.4 活跃性与性能
### 1.2 对象的共享
#### 1.2.1 可见性
##### 1.2.1.1 失效数据
    当线程访问某个变量时，可能得到一个已经失效的值。还有一种情况，一个线程可能获得某个变量的最新值，而另一个线程获得失效得值。
    失效数据会导致：1、计算结果错误。2、活跃性和性能问题。3、意料之外的异常。
##### 1.2.1.2 非原子的64位操作
    最低安全性：线程在没有同步的情况下，访问某个变量时得到的值时之前某个线程设置的某个值而不是随机值。
    最低安全性不能保证非volatile类型的double和long，因为java虚拟机允许64位的读写操作分为两个32位的操作。这样可能会导致得到一个值的高32和另一个值的低32
##### 1.2.1.3 加锁与可见性
    加锁的意义不仅仅局限于互斥，还包括内存可见性。为了确保线程能看到最新值，所有执行读操作和写操作的线程再同一个锁中必须同步。
##### 1.2.1.4 volatile变量
    volatile时一种比synchronized更加轻量级的同步机制。加锁机制提供了互斥与可见性，但是volatile只确保可见性。
### 1.3 线程封闭
    不共享数据，只能再当前线程访问变量。是实现线程安全最简单的方式。
#### 1.3.1 Ad-hoc线程封闭
    维护线程安全性完全由程序来实现，要尽量避免使用这个方式实现线程封闭。
#### 1.3.2 栈封闭
    栈封闭是线程封闭的一种特例，在栈封闭中，只有通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中。
    防止线程封闭被破坏需要防止需要封闭的对象逸出。
#### 1.3.3 ThreadLocal
    这个类可以使线程中保存的某个值与保存值得对象关联起来。通常用于防止对可变得单实例变量或全局变量进行共享。
### 1.4 不变性
    不可变对象一定是线程安全的
    不可变对象：1、创建后其状态不可修改。2、所有域都是final型（也有例外，如String）。3、对象是正确创建的（在创建对象期间，this引用没有逸出）
#### 1.4.1
